# 基于洛书（Losu）编程语言与 Web Assembly 的编译与 OS 演示系统

---

## 项目简介

本项目基于洛书（Losu）编程语言与 Web Assembly 技术，打造一个集编程教学与操作系统原理演示于一体的交互式网站。用户可以在浏览器中编写 Losu 代码，体验编译、虚拟机运行、内存管理、线程调度、文件操作等底层 OS 功能的可视化过程，助力系统能力学习与创新实践。

本项目为 2025 年全国大学生计算机系统能力大赛-操作系统设计赛（全国）- OS功能挑战赛道参赛作品。

## 语义分析实验介绍

### 实验概述

语义分析（Semantic Analysis）是编译器的第三个阶段，主要负责检查程序的语义正确性，构建符号表，进行类型检查，并为代码生成阶段准备必要的语义信息。本实验通过洛书语言编译器的语义分析器，帮助学生理解语义分析的基本原理和实现方法。

### 学习目标

- **理解语义分析的作用**：掌握语义分析在编译过程中的地位和重要性
- **掌握符号表管理**：学习如何构建和管理符号表，处理作用域和名称绑定
- **了解类型系统**：理解类型检查的原理和洛书语言的类型系统
- **体验语义检查过程**：通过实际运行观察各种语义错误的检测和报告

### 实验内容

#### 1. 语义分析的主要任务

**符号表管理**
- 声明处理：记录变量、函数、类的声明信息
- 作用域管理：处理嵌套作用域和名称可见性
- 名称解析：将标识符绑定到对应的声明
- 重复声明检查：检测同一作用域内的重复声明

**类型检查**
- 类型兼容性：检查赋值、参数传递的类型兼容性
- 运算符类型检查：验证运算符操作数的类型正确性
- 函数调用检查：验证函数调用的参数数量和类型
- 返回类型检查：确保函数返回值类型正确

**语义约束检查**
- 变量使用前声明：确保变量在使用前已声明
- 函数返回路径：检查所有代码路径都有适当的返回
- 异步语法检查：验证 `yield` 只在异步函数中使用
- 类继承检查：验证类继承关系的正确性

#### 2. 洛书语言的语义特性

**动态类型系统**
- 运行时类型：变量类型在运行时确定
- 类型推导：根据上下文推导变量类型
- 多态支持：同一变量可以存储不同类型的值

**软关键字处理**
- 上下文敏感：根据上下文确定标识符的语义
- 关键字重定义：某些关键字可以在特定上下文中作为标识符

**异步语义**
- 异步函数标记：标记异步函数和生成器
- `yield` 语义检查：确保 `yield` 在正确的上下文中使用
- 协程调用检查：验证异步函数的调用方式

**面向对象语义**
- 类继承关系：构建类的继承层次
- 方法重写检查：验证方法重写的正确性
- `self` 参数处理：确保实例方法的 `self` 参数正确

#### 3. 符号表结构

**作用域层次**
```
GlobalScope (全局作用域)
├── ModuleScope (模块作用域)
├── ClassScope (类作用域)
│   ├── MethodScope (方法作用域)
│   │   └── LocalScope (局部作用域)
│   └── PropertyScope (属性作用域)
└── FunctionScope (函数作用域)
    └── LocalScope (局部作用域)
```

**符号表项**
```
Symbol {
    name: string,           // 符号名称
    type: Type,            // 符号类型
    kind: SymbolKind,      // 符号种类 (变量/函数/类)
    scope: Scope,          // 所属作用域
    line: int,             // 声明位置
    attributes: []         // 额外属性
}
```

#### 4. 示例代码分析

**变量声明和使用**
```losu
let x = 10              # 声明整数变量
let y = "hello"         # 声明字符串变量
let z = x + 1           # 类型推导：z 为整数
print(x, y, z)          # 使用前面声明的变量
```

语义分析结果：
- 在全局作用域中记录 x, y, z 的声明
- 检查 x + 1 的类型兼容性
- 验证 print 函数调用的参数

**函数定义和调用**
```losu
def calculate(a, b):
    let result = a + b
    return result

let sum = calculate(5, 3)
let invalid = calculate(5)    # 错误：参数数量不匹配
```

**类和继承**
```losu
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        print(self.name, "makes a sound")

class Dog(Animal):
    def speak(self):          # 方法重写
        print(self.name, "barks")

let dog = Dog("Rex")
dog.speak()
```

**异步编程语义**
```losu
async def producer(io, id):
    for i in 1,10:
        yield                 # 正确：在异步函数中使用 yield
        
def normal_func():
    yield                     # 错误：在非异步函数中使用 yield
```

#### 5. 常见语义错误

**名称错误**
- 未声明变量：`print(undefined_var)`
- 重复声明：`let x = 1; let x = 2`
- 作用域错误：访问不可见的变量

**类型错误**
- 类型不匹配：`let x = 5; x = "hello"`（如果启用强类型检查）
- 运算符类型错误：`"hello" + 5`（在某些上下文中）
- 函数调用错误：参数数量或类型不匹配

**语义约束错误**
- 异步错误：在非异步函数中使用 `yield`
- 返回路径错误：函数没有返回值
- 继承错误：循环继承、继承不存在的类

### 操作步骤

1. **访问语义分析页面**：在主页侧边栏点击"语义分析"进入实验页面
2. **选择示例代码**：从预设的示例中选择，或编写包含各种语义结构的代码
3. **执行语义分析**：点击"分析"按钮，系统调用语义分析器
4. **查看分析结果**：观察语义分析的输出，包括：
   - 符号表内容：变量、函数、类的声明信息
   - 作用域信息：各级作用域的嵌套关系
   - 类型信息：推导出的类型信息
   - 错误报告：检测到的语义错误
5. **理解语义规则**：分析不同语义结构的处理方式
6. **错误修复练习**：尝试修复检测到的语义错误

### 实验重点

#### 符号表管理
- **作用域处理**：理解嵌套作用域的管理机制
- **名称绑定**：观察标识符如何绑定到声明
- **生命周期**：了解符号的生命周期管理

#### 类型系统
- **类型推导**：观察洛书语言的类型推导机制
- **类型兼容性**：理解不同类型间的兼容性规则
- **多态处理**：了解动态类型的处理方式

#### 语义约束
- **语法糖语义**：理解语法糖的语义转换
- **异步语义**：掌握异步编程的语义规则
- **面向对象语义**：理解类和继承的语义处理

### 技术实现

- **递归遍历**：通过递归遍历 AST 进行语义分析
- **符号表栈**：使用栈结构管理嵌套作用域
- **类型推导引擎**：实现类型推导和检查算法
- **错误收集**：收集并报告所有语义错误

### 实验价值

通过语义分析实验，学生将：
- 深入理解编译器的语义处理过程
- 掌握符号表和作用域的管理方法
- 了解类型系统的设计和实现
- 学会分析和解决各种语义错误

### 扩展思考

1. **类型系统设计**：静态类型 vs 动态类型的权衡
2. **作用域规则**：不同编程语言的作用域规则对比
3. **语义分析优化**：如何提高语义分析的效率
4. **错误报告质量**：如何提供更好的错误信息和修复建议

通过本实验，学生将全面理解编译器的语义分析阶段，为最终的代码生成阶段做好准备。