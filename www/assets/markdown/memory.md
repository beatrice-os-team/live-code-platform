# 基于洛书（Losu）编程语言与 Web Assembly 的编译与 OS 演示系统

---

## 项目简介

本项目基于洛书（Losu）编程语言与 Web Assembly 技术，打造一个集编程教学与操作系统原理演示于一体的交互式网站。用户可以在浏览器中编写 Losu 代码，体验编译、虚拟机运行、内存管理、线程调度、文件操作等底层 OS 功能的可视化过程，助力系统能力学习与创新实践。

本项目为 2025 年全国大学生计算机系统能力大赛-操作系统设计赛（全国）- OS功能挑战赛道参赛作品。

## 内存管理实验介绍

### 实验概述

内存管理是操作系统的核心功能之一，也是洛书虚拟机的重要组成部分。本实验通过可视化的方式展示洛书虚拟机的内存分配、垃圾回收和内存优化过程，帮助学生理解现代编程语言运行时的内存管理机制。

### 学习目标

- **理解内存管理的重要性**：掌握内存管理在程序运行中的关键作用
- **掌握垃圾回收原理**：学习自动内存管理的基本原理和算法
- **了解内存分配策略**：熟悉不同的内存分配和回收策略
- **体验内存泄漏检测**：通过实际案例理解内存泄漏的成因和检测方法

### 实验内容

#### 1. 洛书虚拟机内存模型

**内存布局**
- **代码段（Code Segment）**：存储编译后的字节码指令
- **常量池（Constant Pool）**：存储字符串、数字等常量数据
- **栈区（Stack Area）**：
  - 操作数栈：用于表达式计算的临时存储
  - 调用栈：存储函数调用信息和局部变量
- **堆区（Heap Area）**：存储动态分配的对象和数据结构
- **全局区（Global Area）**：存储全局变量和模块信息

**内存分配单位**
- 对象头：包含类型信息、GC标记等元数据
- 对象体：存储实际数据内容
- 内存对齐：确保内存访问效率

#### 2. 垃圾回收算法

**标记-清除算法（Mark-and-Sweep）**
- 标记阶段：从根对象开始，标记所有可达对象
- 清除阶段：回收所有未标记的对象
- 优点：简单有效，处理循环引用
- 缺点：可能产生内存碎片

**引用计数算法（Reference Counting）**
- 实时维护对象的引用计数
- 当引用计数为零时立即回收
- 优点：实时回收，内存使用可预测
- 缺点：无法处理循环引用，开销较大

**分代回收算法（Generational GC）**
- 年轻代：频繁分配和回收的短生命周期对象
- 老年代：长期存活的对象，回收频率较低
- 基于"大部分对象生命周期短"的假设进行优化

#### 3. 内存分配策略

**首次适应算法（First Fit）**
- 从内存开始位置查找第一个足够大的空闲块
- 实现简单，分配速度快
- 可能在内存前部产生碎片

**最佳适应算法（Best Fit）**
- 选择最小的满足需求的空闲块
- 内存利用率较高
- 搜索时间较长，可能产生小碎片

**最坏适应算法（Worst Fit）**
- 选择最大的空闲块进行分配
- 留下的剩余空间相对较大
- 内存利用率较低

**BGET内存分配器**
- 洛书虚拟机采用的高效内存分配器
- 结合首次适应和最佳适应的优点
- 支持内存池和快速分配

#### 4. 实验场景演示

**基本对象分配**
```losu
# 创建各种类型的对象
let number = 42           # 数字对象
let string = "Hello"      # 字符串对象  
let array = [1, 2, 3]     # 数组对象
let dict = {"key": "value"} # 字典对象

print("内存使用情况：")
# 显示当前内存使用量
```

**大对象分配**
```losu
# 分配大量内存测试
let large_array = []
for i in 1, 10000:
    large_array.append("item_" & str(i))

print("大对象分配完成")
```

**循环引用场景**
```losu
class Node:
    def __init__(self, value):
        self.value = value
        self.next = null
        self.prev = null

# 创建循环引用
let node1 = Node(1)
let node2 = Node(2)
node1.next = node2
node2.prev = node1  # 形成循环引用
```

**内存泄漏示例**
```losu
# 模拟内存泄漏场景
let global_cache = {}

def create_objects():
    for i in 1, 1000:
        let obj = {"id": i, "data": "x" * 1000}
        global_cache[i] = obj  # 对象被全局引用，无法回收

# 重复调用会导致内存持续增长
create_objects()
```

#### 5. 可视化内容

**内存使用图表**
- 实时显示内存使用量变化
- 区分不同类型对象的内存占用
- 显示垃圾回收的触发时机和效果

**对象生命周期追踪**
- 显示对象的创建、使用和回收过程
- 标识对象之间的引用关系
- 可视化引用图和回收路径

**内存布局视图**
- 展示虚拟机内存的详细布局
- 显示栈、堆、常量池等区域
- 实时更新内存分配状态

### 操作步骤

1. **访问内存管理页面**：在主页侧边栏点击"内存管理"进入实验页面
2. **选择实验场景**：从预设的内存管理场景中选择，或编写自定义代码
3. **开始内存监控**：启动内存使用监控和可视化
4. **执行代码**：运行洛书代码，观察内存变化
5. **分析内存使用**：查看内存分配图表和统计信息：
   - 总内存使用量
   - 不同类型对象的分布
   - 垃圾回收的触发频率
   - 内存回收效率
6. **手动触发GC**：主动触发垃圾回收，观察回收效果

### 实验重点

#### 内存分配理解
- **对象创建过程**：观察不同类型对象的内存分配
- **内存增长模式**：理解程序运行时内存使用的变化
- **内存碎片**：观察内存碎片的产生和影响

#### 垃圾回收机制
- **GC触发条件**：了解什么情况下会触发垃圾回收
- **回收效果**：观察垃圾回收对内存使用的影响
- **性能影响**：理解垃圾回收对程序性能的影响

#### 内存优化
- **对象池技术**：学习如何通过对象重用减少内存分配
- **引用管理**：理解如何避免内存泄漏
- **内存调优**：掌握内存使用的优化策略

### 技术实现

- **WebAssembly内存监控**：通过WASM接口获取虚拟机内存信息
- **实时数据可视化**：使用图表库展示内存使用趋势
- **内存分析工具**：提供详细的内存使用分析
- **性能监控**：监控垃圾回收的性能影响

### 洛书虚拟机内存特色

**动态类型支持**
- 运行时类型信息管理
- 类型转换的内存开销
- 多态对象的内存布局

**协程内存管理**
- 协程栈的分配和管理
- 协程状态的内存保存
- 协程间内存共享

**模块系统内存**
- 模块加载时的内存分配
- 模块间的内存隔离
- 模块卸载时的内存清理

### 实验价值

通过内存管理实验，学生将：
- 深入理解现代编程语言的内存管理机制
- 掌握垃圾回收算法的原理和实现
- 学会分析和优化程序的内存使用
- 了解内存泄漏的成因和防范方法

### 扩展思考

1. **不同GC算法的比较**：标记-清除 vs 复制算法 vs 分代回收
2. **内存管理策略**：手动管理 vs 自动管理的权衡
3. **性能优化**：如何在内存使用和性能之间找到平衡
4. **大规模应用**：在大型应用中如何设计有效的内存管理策略

通过本实验，学生将全面了解操作系统和虚拟机的内存管理原理，为系统编程和性能优化奠定基础。 