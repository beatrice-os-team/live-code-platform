# 基于洛书（Losu）编程语言与 Web Assembly 的编译与 OS 演示系统

---

## 项目简介

本项目基于洛书（Losu）编程语言与 Web Assembly 技术，打造一个集编程教学与操作系统原理演示于一体的交互式网站。用户可以在浏览器中编写 Losu 代码，体验编译、虚拟机运行、内存管理、线程调度、文件操作等底层 OS 功能的可视化过程，助力系统能力学习与创新实践。

本项目为 2025 年全国大学生计算机系统能力大赛-操作系统设计赛（全国）- OS功能挑战赛道参赛作品。

## 代码生成实验介绍

### 实验概述

代码生成（Code Generation）是编译器的最后阶段，负责将语义分析后的抽象语法树转换为目标代码。在洛书编译器中，代码生成阶段将 AST 转换为洛书虚拟机的字节码指令。本实验帮助学生理解代码生成的基本原理，掌握从高级语言到机器代码的转换过程。

### 学习目标

- **理解代码生成的作用**：掌握代码生成在编译过程中的地位和重要性
- **掌握指令选择**：学习如何将高级语言结构映射到目标指令
- **了解虚拟机架构**：熟悉洛书虚拟机的指令集和执行模型
- **体验代码优化**：观察编译器如何进行基本的代码优化

### 实验内容

#### 1. 洛书虚拟机架构

**栈式虚拟机**
- 操作数栈：用于存储中间计算结果
- 调用栈：管理函数调用和局部变量
- 堆内存：存储对象和动态分配的内存
- 常量池：存储字符串、数字等常量

**指令集架构**
- 算术指令：`ADD`, `SUB`, `MUL`, `DIV`, `MOD`, `POW`
- 逻辑指令：`AND`, `OR`, `NOT`, `XOR`
- 比较指令：`EQ`, `NE`, `LT`, `LE`, `GT`, `GE`
- 栈操作：`PUSH`, `POP`, `DUP`, `SWAP`
- 跳转指令：`JMP`, `JIF`, `JNIF`, `CALL`, `RET`
- 内存操作：`LOAD`, `STORE`, `NEW`, `GET`, `SET`

**数据类型**
- 基本类型：整数、浮点数、布尔值、字符串
- 复合类型：数组、对象、函数
- 特殊类型：空值（null）、未定义（undefined）

#### 2. 代码生成策略

**表达式代码生成**
- 后缀表达式：将中缀表达式转换为后缀形式
- 栈式计算：利用操作数栈进行计算
- 类型转换：处理不同类型间的转换
- 短路求值：逻辑运算的优化

**语句代码生成**
- 赋值语句：变量赋值的代码生成
- 控制流：if、for、while 的跳转指令生成
- 函数调用：参数传递和返回值处理
- 异常处理：try-catch 的代码生成

**函数和类的代码生成**
- 函数序言和尾声：栈帧的建立和清理
- 参数传递：参数的压栈和访问
- 局部变量：局部变量的分配和访问
- 闭包处理：闭包变量的捕获和访问

#### 3. 字节码指令示例

**算术表达式**
```losu
let result = 2 + 3 * 4
```
生成的字节码：
```assembly
PUSH    2           # 将 2 压入栈
PUSH    3           # 将 3 压入栈  
PUSH    4           # 将 4 压入栈
MUL                 # 计算 3 * 4
ADD                 # 计算 2 + (3 * 4)
STORE   0           # 存储到局部变量 result
```

**函数调用**
```losu
def add(a, b):
    return a + b

let sum = add(5, 3)
```
生成的字节码：
```assembly
# 函数定义
FUNC_START  add     # 函数开始标记
LOAD    0           # 加载参数 a
LOAD    1           # 加载参数 b  
ADD                 # 计算 a + b
RET                 # 返回结果

# 函数调用
PUSH    5           # 压入参数 5
PUSH    3           # 压入参数 3
CALL    add, 2      # 调用函数，2个参数
STORE   1           # 存储结果到 sum
```

**条件语句**
```losu
if x > 0:
    print("positive")
else:
    print("non-positive")
```
生成的字节码：
```assembly
LOAD    0           # 加载变量 x
PUSH    0           # 压入常量 0
GT                  # 比较 x > 0
JIF     else_label  # 如果为假跳转到 else
PUSH    "positive"  # 真分支
CALL    print, 1
JMP     end_label
else_label:
PUSH    "non-positive" # 假分支
CALL    print, 1
end_label:
```

**循环语句**
```losu
for i in 1,5:
    print(i)
```
生成的字节码：
```assembly
PUSH    1           # 循环起始值
STORE   0           # 存储到变量 i
loop_start:
LOAD    0           # 加载变量 i
PUSH    5           # 循环结束值
GT                  # 比较 i > 5
JIF     loop_end    # 如果为真跳出循环
LOAD    0           # 加载变量 i
CALL    print, 1    # 调用 print
LOAD    0           # 加载变量 i
PUSH    1           # 增量
ADD                 # i = i + 1
STORE   0           # 存储回变量 i
JMP     loop_start  # 跳转到循环开始
loop_end:
```

#### 4. 异步代码生成

**协程状态机**
```losu
async def producer(io, id):
    for i in 1,10:
        io.push('data: ' & str(i))
        yield
```

生成的状态机代码：
```assembly
CORO_START  producer    # 协程开始
CORO_STATE  0           # 状态 0：初始化
    PUSH    1
    STORE   2           # i = 1
CORO_STATE  1           # 状态 1：循环体
    LOAD    2           # 加载 i
    PUSH    10
    GT                  # i > 10?
    JIF     coro_end
    # 生成数据并 yield
    LOAD    0           # io
    PUSH    "data: "
    LOAD    2           # i
    CALL    str, 1
    CONCAT              # 字符串连接
    CALL    push, 2     # io.push(...)
    YIELD   1           # yield 并设置下一状态
    LOAD    2           # i
    PUSH    1
    ADD                 # i = i + 1
    STORE   2
    JMP     state_1     # 继续循环
coro_end:
    CORO_END
```

#### 5. 代码优化技术

**基本块优化**
- 常量折叠：编译时计算常量表达式
- 死代码消除：移除不可达的代码
- 公共子表达式消除：避免重复计算

**示例：常量折叠**
```losu
let x = 2 + 3 * 4    # 优化前
let x = 14           # 优化后
```

**循环优化**
- 循环不变量提升：将循环内的不变计算移出循环
- 循环展开：减少循环控制开销

**函数内联**
- 小函数内联：将简单函数的调用替换为函数体
- 减少函数调用开销

### 操作步骤

1. **访问代码生成页面**：在主页侧边栏点击"代码生成"进入实验页面
2. **选择示例代码**：从预设的示例中选择，或编写自定义的洛书代码
3. **执行代码生成**：点击"生成"按钮，系统调用代码生成器
4. **查看字节码输出**：观察生成的字节码指令，包括：
   - 指令序列：完整的字节码指令列表
   - 常量池：程序中使用的常量
   - 符号表：变量和函数的地址映射
   - 调试信息：源代码行号与字节码的对应关系
5. **分析代码质量**：评估生成代码的效率和正确性
6. **优化效果观察**：对比优化前后的代码差异

### 实验重点

#### 指令选择
- **语言结构映射**：理解高级语言结构如何映射到字节码
- **栈式计算**：掌握基于栈的计算模型
- **控制流转换**：理解控制流语句的字节码表示

#### 虚拟机理解
- **执行模型**：理解虚拟机的执行过程
- **内存管理**：了解虚拟机的内存组织
- **指令集设计**：理解指令集的设计原则

#### 代码优化
- **性能提升**：观察优化对程序性能的影响
- **空间优化**：了解代码大小的优化技术
- **编译时计算**：理解编译时优化的价值

### 技术实现

- **AST 遍历**：递归遍历抽象语法树生成代码
- **符号解析**：将符号引用转换为地址或偏移
- **跳转标签管理**：处理分支和循环的跳转目标
- **寄存器分配**：虚拟寄存器到物理位置的映射

### 洛书虚拟机特色

**协程支持**
- 协程状态保存和恢复
- yield 指令的实现
- 协程调度机制

**垃圾回收**
- 标记-清除算法
- 引用计数优化
- 分代回收策略

**动态类型**
- 运行时类型检查
- 类型标签管理
- 动态方法调度

### 实验价值

通过代码生成实验，学生将：
- 完整理解编译器的工作流程
- 掌握虚拟机的设计和实现
- 了解代码优化的基本技术
- 理解高级语言的底层实现

### 扩展思考

1. **目标代码选择**：字节码 vs 机器代码的权衡
2. **优化策略**：不同优化技术的适用场景
3. **虚拟机设计**：栈式 vs 寄存器式虚拟机
4. **JIT 编译**：动态编译技术的原理和应用

通过本实验，学生将完成从源代码到可执行代码的完整编译过程，深入理解编译器的设计和实现原理。